'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var ReactDOM = require('react-dom');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the MIT License (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 */
/**
 * This is a utility component that is used to manage all the custom responses that are rendered by web chat. When a
 * custom response message is received by web chat, it will fire a "customResponse" event that provides an HTML element
 * to which your application can attach custom content. React portals are a mechanism that allows you to render a
 * component in your React application but attach that component to the HTML element that was provided by web chat.
 *
 * When this component is mounted, it will register a listener for the "customResponse" event from web chat. It will
 * save each event in a list and then render a portal for each event. Each portal will be attached to the element that
 * was created by web chat and is where that custom response should be attached.
 *
 * To use this component, all you need to do is mount is somewhere in your application; it doesn't really matter
 * where but you should make sure that the component does not get unmounted because it will lose all the custom
 * responses that had been received prior to that point.
 */
function CustomResponsePortalsContainer(_a) {
    var webChatInstance = _a.webChatInstance, renderResponse = _a.renderResponse;
    // This state will be used to record all the custom response events that are fired from the widget. These
    // events contain the HTML elements that we will attach our portals to as well as the messages that we wish to
    // render in the message.
    var _b = React.useState([]), customResponseEvents = _b[0], setCustomResponseEvents = _b[1];
    // When the component is mounted, register the custom response handler that will store the references to the custom
    // response events.
    React.useEffect(function () {
        // This handler will fire each time a custom response occurs and we will update our state by appending the event
        // to the end of our events list. We have to make sure to create a new array in order to trigger a rerender.
        function customResponseHandler(event) {
            setCustomResponseEvents(function (eventsArray) { return eventsArray.concat(event); });
        }
        webChatInstance.on({ type: 'customResponse', handler: customResponseHandler });
        // Remove the custom response handler.
        return function () {
            webChatInstance.off({ type: 'customResponse', handler: customResponseHandler });
        };
    }, [webChatInstance]);
    // All we need to do to enable the React portals is to render each portal somewhere in your application (it
    // doesn't really matter where).
    return (React__default["default"].createElement(React__default["default"].Fragment, null, customResponseEvents.map(function mapEvent(event, index) {
        return (
        // eslint-disable-next-line react/no-array-index-key
        React__default["default"].createElement(CustomResponseComponentPortal, { key: index, hostElement: event.data.element }, renderResponse(event, webChatInstance)));
    })));
}
/**
 * This is the component that will attach a React portal to the given host element. The host element is the element
 * provided by web chat where your custom response will be displayed in the DOM. This portal will attach any React
 * children passed to it under this component so you can render the response using your own React application. Those
 * children will be rendered under the given element where it lives in the DOM.
 */
function CustomResponseComponentPortal(_a) {
    var hostElement = _a.hostElement, children = _a.children;
    return ReactDOM__default["default"].createPortal(children, hostElement);
}
var CustomResponsePortalsContainerExport = React__default["default"].memo(CustomResponsePortalsContainer);

/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the MIT License (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 */
// The default host URL where the production version of web chat is hosted.
var DEFAULT_BASE_URL$1 = 'https://web-chat.global.assistant.watson.appdomain.cloud';
// Indicate if debugging is enabled.
var debug = false;
/**
 * This is a component wrapper for using the withWebChat high-order-component as well as for providing support for
 * handling custom responses in portals.  This can be rendered anywhere in your application but you should make sure
 * it doesn't get unmounted during in the middle of your App's life or it will lose any custom responses that were
 * previously received.
 *
 * Note that this container will override any config.onLoad property you have set. If you need access to the web
 * chat instance or need to perform additional customizations of web chat when it loads, use the onBeforeRender
 * callback prop to this component.
 */
function WebChatContainer(_a) {
    var onBeforeRender = _a.onBeforeRender, onAfterRender = _a.onAfterRender, renderCustomResponse = _a.renderCustomResponse, config = _a.config, instanceRef = _a.instanceRef, hostURL = _a.hostURL;
    // A state value that contains the current instance of web chat.
    var _b = React.useState(), instance = _b[0], setInstance = _b[1];
    // The most recent web chat that was load by this component.
    var managedWebChatRef = React.useRef();
    // The previous web chat config.
    var previousConfigRef = React.useRef();
    React.useEffect(function () {
        var previousConfig = previousConfigRef.current;
        previousConfigRef.current = config;
        if (previousConfig !== config) {
            // Each time the web chat config settings change (or this component is mounted), we need to destroy any previous
            // web chat and create a new web chat.
            destroyWebChat(managedWebChatRef.current, setInstance, instanceRef);
            // We'll use this managed object to keep track of the web chat instance we are creating for this effect.
            var managedWebChat_1 = {
                instance: null,
                shouldDestroy: false,
                webChatConfig: config,
            };
            managedWebChatRef.current = managedWebChat_1;
            logger(managedWebChat_1.webChatConfig, "Creating a new web chat due to configuration change.");
            // Kick off the creation of a new web chat. This is multistep, asynchronous process.
            loadWebChat(managedWebChat_1, hostURL, setInstance, instanceRef, onBeforeRender, onAfterRender).catch(function (error) {
                logger(managedWebChat_1.webChatConfig, 'An error occurred loading web chat', error);
                destroyWebChat(managedWebChat_1, setInstance, instanceRef);
            });
            return function () {
                logger(managedWebChat_1.webChatConfig, "Destroying web chat due to component unmounting.");
                destroyWebChat(managedWebChat_1, setInstance, instanceRef);
                previousConfigRef.current = null;
            };
        }
        return undefined;
    }, [config, hostURL]);
    if (renderCustomResponse && instance) {
        return React__default["default"].createElement(CustomResponsePortalsContainerExport, { webChatInstance: instance, renderResponse: renderCustomResponse });
    }
    return null;
}
/**
 * Loads a new instance of web chat.
 */
function loadWebChat(managedWebChat, hostURL, setInstance, instanceRef, onBeforeRender, onAfterRender) {
    return __awaiter(this, void 0, void 0, function () {
        var webChatConfig, message, configWithoutOnLoad, instance;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    webChatConfig = managedWebChat.webChatConfig;
                    // The first step is to make sure the javascript for web chat is loaded.
                    return [4 /*yield*/, ensureWebChatScript(webChatConfig, hostURL)];
                case 1:
                    // The first step is to make sure the javascript for web chat is loaded.
                    _a.sent();
                    if (managedWebChat.shouldDestroy) {
                        logger(webChatConfig, "Destroying web chat before an instance is created.");
                        destroyWebChat(managedWebChat, setInstance, instanceRef);
                        return [2 /*return*/];
                    }
                    // Now create an instance of web chat.
                    if (webChatConfig.onLoad) {
                        message = 'Do not use onLoad in the web chat config. Use the WebChatContainer onBeforeRender or onAfterRender prop instead.';
                        logger(webChatConfig, message);
                    }
                    logger(webChatConfig, "Creating web chat instance.");
                    configWithoutOnLoad = __assign(__assign({}, webChatConfig), { onLoad: null });
                    return [4 /*yield*/, window.loadWatsonAssistantChat(configWithoutOnLoad)];
                case 2:
                    instance = _a.sent();
                    // Once the instance is created, call the onBeforeRender and then render and then onAfterRender.
                    return [4 /*yield*/, (onBeforeRender === null || onBeforeRender === void 0 ? void 0 : onBeforeRender(instance))];
                case 3:
                    // Once the instance is created, call the onBeforeRender and then render and then onAfterRender.
                    _a.sent();
                    logger(webChatConfig, "Calling render.");
                    return [4 /*yield*/, instance.render()];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, (onAfterRender === null || onAfterRender === void 0 ? void 0 : onAfterRender(instance))];
                case 5:
                    _a.sent();
                    // Update the state of the parent component with the instance.
                    setInstance(instance);
                    managedWebChat.instance = instance;
                    if (instanceRef) {
                        instanceRef.current = instance;
                    }
                    if (managedWebChat.shouldDestroy) {
                        logger(webChatConfig, "Destroying web chat after an instance is created but before calling onLoad.");
                        destroyWebChat(managedWebChat, setInstance, instanceRef);
                    }
                    return [2 /*return*/];
            }
        });
    });
}
/**
 * Destroys an instance of web chat and marks it destroyed.
 */
function destroyWebChat(managedWebChat, setInstance, instanceRef) {
    if (managedWebChat) {
        if (managedWebChat.instance) {
            logger(managedWebChat.webChatConfig, "Destroying web chat instance.");
            managedWebChat.instance.destroy();
        }
        managedWebChat.shouldDestroy = true;
        managedWebChat.instance = null;
    }
    setInstance(null);
    if (instanceRef) {
        instanceRef.current = null;
    }
}
/**
 * A public function that can be used to turn logging off or on.
 */
function setEnableDebug(enableDebug) {
    debug = enableDebug;
}
/**
 * A convenience function for logging to the console.
 */
function logger(webChatConfig) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (debug) {
        var namespaceLabel = (webChatConfig === null || webChatConfig === void 0 ? void 0 : webChatConfig.namespace) ? ": Namespace ".concat(webChatConfig.namespace) : '';
        // eslint-disable-next-line no-console
        console.log.apply(console, __spreadArray(["[IBM watsonx Assistant WebChatContainer".concat(namespaceLabel, "]")], args, false));
    }
}
/**
 * Ensures that the javascript for web chat has been loaded.
 */
function ensureWebChatScript(webChatConfig, hostURL) {
    return __awaiter(this, void 0, void 0, function () {
        var useURL, scriptURL, loadedWebChatURL, message;
        return __generator(this, function (_a) {
            useURL = hostURL || DEFAULT_BASE_URL$1;
            scriptURL = "".concat(useURL.replace(/\/$/, ''), "/versions/").concat(webChatConfig.clientVersion || 'latest', "/WatsonAssistantChatEntry.js");
            loadedWebChatURL = window.wacWebChatContainerScriptURL;
            if (loadedWebChatURL && loadedWebChatURL !== scriptURL) {
                message = "Web chat has already been loaded using a different URL (".concat(loadedWebChatURL, "). This component does not support loading web chat using multiple URLs including different versions of web chat. The current code attempted to load from ").concat(scriptURL, ".");
                logger(null, message);
            }
            // Check to see if we already have a Promise for loading this script. We're using a window property to cover the
            // case where multiple library instances are being used that can't necessarily share module state.
            if (!window.wacWebChatContainerScriptPromise) {
                logger(null, "Loading the web chat javascript from ".concat(scriptURL, "."));
                window.wacWebChatContainerScriptPromise = new Promise(function (resolve, reject) {
                    var scriptElement = document.createElement('script');
                    scriptElement.onload = function () { return resolve(); };
                    scriptElement.onerror = function () { return reject(); };
                    scriptElement.src = scriptURL;
                    document.head.appendChild(scriptElement);
                    window.wacWebChatContainerScriptURL = scriptURL;
                });
            }
            return [2 /*return*/, window.wacWebChatContainerScriptPromise];
        });
    });
}

/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the MIT License (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 */
var DEFAULT_BASE_URL = 'https://web-chat.global.assistant.watson.appdomain.cloud';
// When withWebChat is first used, loadWebChatScript promise will be set to loadWebChatScript(baseUrl).
// This way we can have multiple withWebChat instances listen to this same promise.
var loadWebChatScriptPromise;
/**
 * Injects a method to create an instance of web chat into the props for the component.
 *
 * withWebChat takes a component and a config argument. The config argument contains two parameters.
 * First, a "debug" option that takes a boolean. When turned on, this will add console.logs outlying the status of the
 * web chat during each step of build and tear down. The second parameter is baseUrl. This is used to identify where
 * the web chat should load from. config.baseUrl is used for internal debugging and development purposes, so you
 * shouldn't have to touch that normally.
 */
function withWebChat(passedConfig) {
    if (passedConfig === void 0) { passedConfig = {}; }
    return function withWebChatWithConfig(WrappedComponent) {
        var displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
        function WithWebChat(props) {
            var config = {
                baseUrl: passedConfig.baseUrl || DEFAULT_BASE_URL,
                debug: passedConfig.debug || false,
            };
            // We track the passed web chat config and the promise that the web chat script has been loaded in state.
            var _a = React__default["default"].useState(), webChatConfig = _a[0], setWebChatConfig = _a[1];
            var webChatLoadedPromise = React__default["default"].useRef(new Deferred());
            /**
             * This function is passed as a prop. We are not able to immediately work to create an instance of web chat until
             * the external script loads so we await createWebChatInstanceReady being resolved. We also need to be able to
             * keep track of if the component is still mounted in all our promises, so we use createWebChatInstanceInternal
             * that is able to keep track of mounted state.
             */
            function createWebChatInstance(passedWebChatConfig) {
                return __awaiter(this, void 0, void 0, function () {
                    var createWebChatInstanceInternal;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                setWebChatConfig(passedWebChatConfig);
                                return [4 /*yield*/, webChatLoadedPromise.current.promise];
                            case 1:
                                createWebChatInstanceInternal = _a.sent();
                                return [2 /*return*/, createWebChatInstanceInternal(passedWebChatConfig)];
                        }
                    });
                });
            }
            // This effect only runs when createWebChatInstance is called. It contains a lot of promises while loading up web chat.
            // Each of these promises checks if isMounted is still set to true before continuing. When the component unmounts,
            // isMounted is set to false. This gives us safety from quick mounting and unmounting that can create problems
            // if we don't stop the promises from continuing to run.
            React__default["default"].useEffect(function () {
                var isMounted = true;
                var instance;
                // If config.debug is true, this method will console.log out the passed messages, prefixed by an identifier to
                // separate from non web chat console.log traffic.
                function logger() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (config.debug) {
                        // eslint-disable-next-line no-console
                        console.log("[IBM watsonx Assistant withWebChat".concat(webChatConfig && webChatConfig.namespace ? ": Namespace \"".concat(webChatConfig.namespace, "\"") : '', "]"), args);
                    }
                }
                // This function manages all the steps to load a web chat and pass the instance back in a promise. It manages making sure
                // the component is still mounted as it runs through async steps and any clean up of the instance on failures.
                // eslint-disable-next-line consistent-return
                function createWebChatInstanceTemplate(passedWebChatConfig) {
                    return __awaiter(this, void 0, void 0, function () {
                        var onLoadReference, error_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!isMounted) return [3 /*break*/, 7];
                                    logger('creating web chat instance');
                                    onLoadReference = passedWebChatConfig.onLoad || function noop() { };
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 5, , 6]);
                                    if (instance) {
                                        // eslint-disable-next-line no-console
                                        console.warn('[IBM watsonx Assistant withWebChat] createWebChatInstance has already been called... destroying previous instance.');
                                        instance.destroy();
                                    }
                                    if (!window.loadWatsonAssistantChat) return [3 /*break*/, 3];
                                    logger('web chat instance being created');
                                    return [4 /*yield*/, window.loadWatsonAssistantChat(passedWebChatConfig)];
                                case 2:
                                    instance = _a.sent();
                                    return [3 /*break*/, 4];
                                case 3: throw new Error('window.loadWatsonAssistantChat is undefined');
                                case 4:
                                    if (isMounted) {
                                        logger('web chat instance created and returned to component');
                                        onLoadReference(instance);
                                    }
                                    else if (instance) {
                                        logger('web chat instance created but component unmounted...destroying instance and aborting.');
                                        instance.destroy();
                                    }
                                    return [2 /*return*/, instance];
                                case 5:
                                    error_1 = _a.sent();
                                    if (instance) {
                                        logger('web chat failed to create instance...destroying instance and aborting.');
                                        instance.destroy();
                                    }
                                    else {
                                        logger('web chat failed to create instance...aborting.');
                                    }
                                    // Throw the error back upstream to be handled inside the component.
                                    throw new Error(error_1);
                                case 6: return [3 /*break*/, 8];
                                case 7:
                                    logger('web chat instance ready to be created, but component unmounted...aborting.');
                                    return [2 /*return*/, instance];
                                case 8: return [2 /*return*/];
                            }
                        });
                    });
                }
                if (webChatConfig) {
                    logger('createWebChatInstance called');
                    // If the script tag for web chat has not been injected on the page, do so now.
                    if (!loadWebChatScriptPromise) {
                        logger('appending web chat scripts to body');
                        loadWebChatScriptPromise = ensureWebChatScript(webChatConfig, config.baseUrl);
                    }
                    loadWebChatScriptPromise
                        .then(function () {
                        logger('web chat script loaded');
                        if (isMounted) {
                            logger('web chat script loaded and component is still mounted. Setting createWebChatInstance.');
                            webChatLoadedPromise.current.resolve(createWebChatInstanceTemplate);
                        }
                        else {
                            logger('web chat script loaded and component is no longer mounted...aborting.');
                        }
                    })
                        .catch(function (error) {
                        logger('web chat script failed', error);
                        if (isMounted) {
                            logger('web chat script failed to load. createWebChatInstance will reject.');
                            webChatLoadedPromise.current.reject("[IBM watsonx Assistant withWebChat".concat(webChatConfig && webChatConfig.namespace ? ": Namespace \"".concat(webChatConfig.namespace, "\"") : '', "] web chat failed to load."));
                        }
                        else {
                            logger('web chat script failed to load and component is no longer mounted...aborting.');
                        }
                    });
                }
                return function () {
                    // By setting isMounted to false, we prevent post async code from running when the component is no longer mounted.
                    isMounted = false;
                    if (webChatConfig) {
                        if (instance) {
                            logger('component has unmounted...destroying web chat instance and aborting');
                            instance.destroy();
                        }
                        else {
                            logger('component has unmounted before web chat instance was created...aborting');
                        }
                    }
                };
            }, [webChatConfig, webChatLoadedPromise]);
            var _b = props, forwardedRef = _b.forwardedRef, restPropsTemp = __rest(_b, ["forwardedRef"]);
            var rest = restPropsTemp;
            return React__default["default"].createElement(WrappedComponent, __assign({}, rest, { ref: forwardedRef, createWebChatInstance: createWebChatInstance }));
        }
        var WithForwardedRef = React__default["default"].forwardRef(function (props, ref) { return (React__default["default"].createElement(WithWebChat, __assign({}, props, { forwardedRef: ref }))); });
        WithForwardedRef.displayName = displayName;
        return WithForwardedRef;
    };
}
/**
 * A class to mirror the old jQuery deferred to allow exposing of resolve, reject to external scripts to call.
 *
 * @see https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md
 */
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this.state = 'pending';
        this.fate = 'unresolved';
        this.promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
        this.promise.then(function () {
            _this.state = 'fulfilled';
        }, function () {
            _this.state = 'rejected';
        });
    }
    Deferred.prototype.resolve = function (value) {
        this.fate = 'resolved';
        this._resolve(value);
    };
    Deferred.prototype.reject = function (reason) {
        this.fate = 'resolved';
        this._reject(reason);
    };
    Deferred.prototype.isResolved = function () {
        return this.fate === 'resolved';
    };
    Deferred.prototype.isPending = function () {
        return this.state === 'pending';
    };
    Deferred.prototype.isFulfilled = function () {
        return this.state === 'fulfilled';
    };
    Deferred.prototype.isRejected = function () {
        return this.state === 'rejected';
    };
    return Deferred;
}());

/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the MIT License (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 */
/**
 * This component can be used if you want to render web chat inside a custom element. It will perform two functions:
 *
 * 1. It will create the custom element as part of the React application.
 * 2. It will attach web chat to the custom element and use the WebChatContainer component to manage the life cycle
 * of the web chat instance.
 */
function WebChatCustomElement(props) {
    var _this = this;
    var className = props.className, id = props.id, onViewChange = props.onViewChange, config = props.config, onBeforeRender = props.onBeforeRender, containerProps = __rest(props, ["className", "id", "onViewChange", "config", "onBeforeRender"]);
    var _a = React.useState(), customElement = _a[0], setCustomElement = _a[1];
    // Make sure to memoize the config object. If we pass a new object to WebChatContainer (even if all the properties
    // inside of it are the same), the container will just continually destroy and recreate the web chat instance
    // because it thinks the config keeps changing.
    var useConfig = React.useMemo(function () {
        return __assign(__assign({}, config), { element: customElement });
    }, [config, customElement]);
    var onBeforeRenderOverride = React.useCallback(function (instance) { return __awaiter(_this, void 0, void 0, function () {
        /**
         * A default handler for the "view:change" event. This will be used to show or hide the web chat main window
         * using a simple classname.
         */
        function defaultViewChangeHandler(event, instance) {
            if (event.newViewState.mainWindow) {
                instance.elements.getMainWindow().removeClassName('HideWebChat');
            }
            else {
                instance.elements.getMainWindow().addClassName('HideWebChat');
            }
        }
        return __generator(this, function (_a) {
            instance.on({ type: 'view:change', handler: onViewChange || defaultViewChangeHandler });
            return [2 /*return*/, onBeforeRender === null || onBeforeRender === void 0 ? void 0 : onBeforeRender(instance)];
        });
    }); }, [onBeforeRender, onViewChange]);
    return (React__default["default"].createElement(React__default["default"].Fragment, null,
        React__default["default"].createElement("div", { className: className, id: id, ref: setCustomElement }),
        customElement && (React__default["default"].createElement(WebChatContainer, __assign({ config: useConfig, onBeforeRender: onBeforeRenderOverride }, containerProps)))));
}

exports.CustomResponsePortalsContainer = CustomResponsePortalsContainerExport;
exports.WebChatContainer = WebChatContainer;
exports.WebChatCustomElement = WebChatCustomElement;
exports.setEnableDebug = setEnableDebug;
exports.withWebChat = withWebChat;
